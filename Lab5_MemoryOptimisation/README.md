# OperatingSystem - Lab5

##  Оптимизація роботи з пам'яттю

### Варіант №1 
Початковий код:
```
void source_code() 
{
    int a[] = { 0,0 };
    int res = 0;

    for (int j = 0; j < 10000000; j++)
    {
        a[0]++;
        a[0]++;
    }

    a[1] = a[0];
}
```

Розберемо кожен рядок: у першому рядку створюється масив із двох елементів, після чого створюється змінна res, якій присвоюється значення 0. Далі запускається цикл розміром в 10000000 ітерацій, на кожній ітерації якого перший елемент масиву інкрементується двічі. Після чого другому елементу масиву присвоюється значення першого. 

Головним простором для оптимізації даного коду є цикл. У циклі той самий елемент масиву інкрементується двічі. Це означає, що на кожній ітерації циклу програма двічі звертається до тієї ж самої комірки пам'яті, де зберігається перший елемент масиву.

Оптимізуємо даний код: 

```
void updated_code_1()
{
    int a[] = { 0,0 };
    int res = 0;

    for (int j = 0; j < 10000000; j++)
    {
        a[0] += 2;
    }

    a[1] = a[0];
}
```

Тепер на кожній ітерації циклу перший елемент масиву одразу інкрементується на 2. Це зменшує кількість звернень до пам'яті, де зберігається перший елемент масиву вдвічі.

Спробуємо ще оптимізувати наш код: 

```
void updated_code_2()
{
    int a[] = { 0,0 };
    int res = 0;

    for (int j = 0; j < 10000000; j++)
    {
        res += 2;
    }

    a[1] = a[0] = res;
}
```

Нехай інкрементується змінна res, а не елемент масиву. А після закінчення циклу присвоїмо значення змінної res елементам масиву.

Тепер перевіримо середній час виконання кожної із функцій. Кожна функція виконується 2000 разів, після чого рахується середній час її виконання. 

![Screenshot1](https://github.com/Wistony/OperatingSystem_Labs/blob/master/Lab5_MemoryOptimisation/img/1.png)
=
Можна зробити висновок, що звернення на кожній ітерації циклу до змінної res замість елементу масива не прискорило виконання коду. Це логічно, оскільки елемент масиву є такою ж змінною як і змінна res. Тобто доступ до елементу масиву і змінної відбувається за однаковий час. У свою чергу прискорення виконання даного коду було досягнуто завдяки заміні інкремента на 1 двічі на кожній ітерації циклу на інкремент на 2 на кожній ітерації циклу. Це дозволило зменшити кількість звернень до елемента масиву вдвічі, що прискорило виконання коду в 1.5 раза. 





