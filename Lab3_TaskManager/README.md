# OperatingSystem - Lab3

##  Алгоритми диспетчеризації
#### Варіант №2 - Алгоритм FIFO (First  Input- First Output) з пріоритетами та витісненням.
##### Опис алгоритму
Даний код емулює логіку роботи диспетчера задач на основі алгоритму FIFO з пріоритетами та витісненням. Аналогом задачі виступає структура **Task**.

##### Структура PageHeader
#
```
struct Task 
{
	unsigned int Id;
	int Duration;
	int Priority;
};
```

- **Id** - унікальний ідентифікатор, за допомогою якого можна ідентифікувати кожну задачу.
- **Duration** - час, який необхідний для виконання задачі (у мілісекундах).
- **Priority** - пріоритет задачі.
#

Час для виконання задачі та пріоритет задачі генерується випадковим чином.
```
Task task = Task(i + 1, rand() % MAX_DURATION + 1, rand() % MIN_PRIORITY + 1);
```
Мінімальний та максимальний пріоритет, максимальний час для виконання задачі задаються за допомогою директиви **#define**.

Суть даного алгоритму в тому, що задачі з однаковим пріоритетом зберігаються в чергах. Спочатку виконуються задачі із найбільшим пріоритетом(чим менше число, тим пріоритет рахується вищим), після чого виконуються задачі із меншим пріоритетом. Витіснення означає, що якщо в момент виконання задачі в чергу потрапляє задача із вищим пріоритетом, то поточна задача перериває своє виконання(витісняється) і потрапляє назад в чергу, а задача із вищим пріоритетом починає виконуватись.

#### Реалізація

Диспетчером задач виступає клас **TaskManager**, який зберігає задачі у векторі, кожен елемент даного вектору - це черга структур **Task**. Кожному пріоритету відповідає свій елемент вектору. Індекс черги з пріоритетом N дорівнює N - 1. Наприклад, задачі із пріоритетом 2 зберігаються у черзі під індексом 2 - 1 = 1.

Програма виконується у двох потоках, в головному потоці виконуються задачі, а в додатковому програма генерує нові задачі з інтесивністю раз в INTENTISY мілісекунд, де INTENSITY - директива препроцесора.

Основні функції диспетчера: 
- **AddTask(Task)** - добавляє нову задачу у відповідну чергу.
- **ExecuteTask()** - виконує задачу з найвищим пріоритетом і перевіряє чи не з'явилась задача із вищим пріоритетом за даний.
- **dump()** - виводить у консоль стан черг на даний момент.

Додаткові функції диспетчера, які рахують метрики необхідні для побудови графіків: **calculateAverageWaitingTimeByPriority()**, **calculateWaitingTime()**,
**calculateAverageWaitingTime()**.

Метрики, які використовуються: середній час очікування, середній час очікування по кожному пріоритету, загальний час очікування, час простою(коли черги порожні і диспетчер не виконує жодної задачі), відсоток простою.
  
#

#### Приклад роботи

##### Код: 
Запустимо програму з наступними параметрами.
```
#define MAX_PRIORITY 1
#define MIN_PRIORITY 16
#define TASK_COUNT 50
#define MAX_DURATION 100
#define INTENSITY 100
```

##### Вивід: 


![Screenshot1](https://github.com/Wistony/OperatingSystem_Labs/blob/master/Lab3_TaskManager/img/1.png)

#

##### Графік залежності середнього часу очікування від кількості задач

![Screenshot1](https://github.com/Wistony/OperatingSystem_Labs/blob/master/Lab3_TaskManager/img/2.png)

#

##### Графік залежності простою ресурсу від інтенсивності вхідного потоку заявок

![Screenshot1](https://github.com/Wistony/OperatingSystem_Labs/blob/master/Lab3_TaskManager/img/3.png)

#

##### Графік залежності середнього часу очікування від  пріоритету

![Screenshot1](https://github.com/Wistony/OperatingSystem_Labs/blob/master/Lab3_TaskManager/img/4.png)

#

#### Висновок 
Перевагою даного алгоритму є те, що завдання із найвищим пріоритетом виконуються дуже швидко. Цьому сприяє наявність в алгоритмі пріоритетів як таких та витіснення.
У свою чергу головним недоліком є дуже великий час очікування для низьких пріоритетів.

